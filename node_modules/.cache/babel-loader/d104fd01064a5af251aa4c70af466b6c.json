{"ast":null,"code":"var debug = AFRAME.utils.debug;\nvar coordinates = AFRAME.utils.coordinates;\nvar warn = debug('components:look-at:warn');\nvar isCoordinates = coordinates.isCoordinates || coordinates.isCoordinate;\ndelete AFRAME.components['look-at'];\n/**\n * Look-at component.\n *\n * Modifies rotation to either track another entity OR do a one-time turn towards a position\n * vector.\n *\n * If tracking an object via setting the component value via a selector, look-at will register\n * a behavior to the scene to update rotation on every tick.\n */\n\nAFRAME.registerComponent('look-at', {\n  schema: {\n    \"default\": '0 0 0',\n    parse: function parse(value) {\n      // A static position to look at.\n      if (isCoordinates(value) || typeof value === 'object') {\n        return coordinates.parse(value);\n      } // A selector to a target entity.\n\n\n      return value;\n    },\n    stringify: function stringify(data) {\n      if (typeof data === 'object') {\n        return coordinates.stringify(data);\n      }\n\n      return data;\n    }\n  },\n  init: function init() {\n    this.target3D = null;\n    this.vector = new THREE.Vector3();\n    this.cameraListener = AFRAME.utils.bind(this.cameraListener, this);\n    this.el.addEventListener('componentinitialized', this.cameraListener);\n    this.el.addEventListener('componentremoved', this.cameraListener);\n  },\n\n  /**\n   * If tracking an object, this will be called on every tick.\n   * If looking at a position vector, this will only be called once (until further updates).\n   */\n  update: function update() {\n    var self = this;\n    var target = self.data;\n    var targetEl; // No longer looking at anything (i.e., look-at=\"\").\n\n    if (!target || typeof target === 'object' && !Object.keys(target).length) {\n      return self.remove();\n    } // Look at a position.\n\n\n    if (typeof target === 'object') {\n      return this.lookAt(new THREE.Vector3(target.x, target.y, target.z));\n    } // Assume target is a string.\n    // Query for the element, grab its object3D, then register a behavior on the scene to\n    // track the target on every tick.\n\n\n    targetEl = self.el.sceneEl.querySelector(target);\n\n    if (!targetEl) {\n      warn('\"' + target + '\" does not point to a valid entity to look-at');\n      return;\n    }\n\n    if (!targetEl.hasLoaded) {\n      return targetEl.addEventListener('loaded', function () {\n        self.beginTracking(targetEl);\n      });\n    }\n\n    return self.beginTracking(targetEl);\n  },\n  tick: function () {\n    var vec3 = new THREE.Vector3();\n    return function (t) {\n      // Track target object position. Depends on parent object keeping global transforms up\n      // to state with updateMatrixWorld(). In practice, this is handled by the renderer.\n      var target3D = this.target3D;\n\n      if (target3D) {\n        target3D.getWorldPosition(vec3);\n        this.lookAt(vec3);\n      }\n    };\n  }(),\n  remove: function remove() {\n    this.el.removeEventListener('componentinitialized', this.cameraListener);\n    this.el.removeEventListener('componentremoved', this.cameraListener);\n  },\n  beginTracking: function beginTracking(targetEl) {\n    this.target3D = targetEl.object3D;\n  },\n  cameraListener: function cameraListener(e) {\n    if (e.detail && e.detail.name === 'camera') {\n      this.update();\n    }\n  },\n  lookAt: function lookAt(position) {\n    var vector = this.vector;\n    var object3D = this.el.object3D;\n\n    if (this.el.getObject3D('camera')) {\n      // Flip the vector to -z, looking away from target for camera entities. When using\n      // lookat from THREE camera objects, this is applied for you, but since the camera is\n      // nested into a Object3D, we need to apply this manually.\n      vector.subVectors(object3D.position, position).add(object3D.position);\n    } else {\n      vector.copy(position);\n    }\n\n    object3D.lookAt(vector);\n  }\n});","map":null,"metadata":{},"sourceType":"script"}